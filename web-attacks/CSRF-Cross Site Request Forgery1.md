### **What is CSRF?**

Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform.

Client Side Request Forgery → When a client is accessing our website, we can do phishing kinda thing, by modifying html. That is known as csrf.

## Session Management :

Some websites have cookie have predictable values.

CSRF Attack  : An attack where the attacker causes the victim to do an action unintentionally while the victim is authenticated(logged-in).

For a CSRF Attack to take place: 
The request should 

1. Do an action(updating email)
2. It should be based on cookie-session handling
3. It shouldn’t have any unpredictable parameters

## Lab: CSRF vulnerability with no defenses

We login with our credentials

Then we will click update email from our account.

It’ll send request to website, we will intercept the request and regenerate csrf for that request, and put the url there as our exploit server and it’ll autosubmit. 

We will then paste the csrf body in our exploit server, which will be accessible by all users.

Once the victim clicks the url, their account will be taken over.


## **How to deliver a CSRF exploit**

Attacker not necessarily needs to make the victim to visit attacker’s website. If attacker can inject xss injection like csrf in the website where victim is logged in, then that’ll be more than useful.

```bash
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">

```

### **Common defences against CSRF**

- **CSRF tokens** - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.
- **SameSite cookies** - SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from triggering these actions cross-site. Since 2021, Chrome enforces `Lax` SameSite restrictions by default. As this is the proposed standard, we expect other major browsers to adopt this behavior in future.
- **Referer-based validation** - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This is generally less effective than CSRF token validation.

When csrf token is implemented properly, then attacker wont have a chance to make a request to website on behalf of victim, as it requires that csrf token.

## Common flaws in CSRF Token:

Websites mostly validate csrf tokens only on POST method and not on GET method.

### **Lab: CSRF where token validation depends on request method**

Change email

Pass that post-request to repeater and analyse. 

You can able to change POST to GET and do the required action.

Now remove the csrf token and see it’ll still works.

Generate csrf-script and paste in exploit script, victim will see the post with auto-submit payloa

## **Validation of CSRF token depends on token being present**

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.
